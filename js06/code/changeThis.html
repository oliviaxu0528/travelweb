<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>change this</title>
</head>
<body>
    <script>
        // 改变this的三种方法：call  bind  apply
        /* 
            call(this,参数1，参数2)  
            apply(this,[参数1，参数2])  
            call和apply都是改变this后立即调用   是一次性的改变this

            bind(this)
            bind是返回改变this后的函数，需要调用才会执行，可以多次调用
            永久性的改变this
        */
        function fn (a,b){
            console.log('this:',this);
            console.log(a,b);
            console.log('this.name:',this.name);
        }
        // fn(5,6)
        var obj = {
            name:'obj',
            age:3,
            say:()=>{
                console.log(1111);
            }
        }
        //  fn.call(this对象,函数参数)               列表传参
        // 使用call来改变this,第一个参数是我们要改变为的this，第二个参数是函数的参数，如果有多个参数使用，隔开
        // call方法会直接调用改变this后的函数
        //  fn.call(obj,'calla','callb')   //this:{name: 'obj', age: 3, say: ƒ}

        // fn.apply(this对象,[函数参数1,函数参数2])      数组传参
         // 使用apply来改变this,第一个参数是我们要改变为的this，第二个参数是一个数组，数组中是函数的参数，
        // apply方法会直接调用改变this后的函数
        // fn.apply(obj,['applya','applyb'])


        // var bindFn = fn.bind(obj,'binda','bindb')
        // console.log(bindFn);
        // bindFn()
        

        // 使用bind改变this,参数为需要改变的this，不会立即调用函数，而是返回一个改变this后的函数，需要调用改变this后的函数才会执行函数内部的代码
        var bindFn = fn.bind(obj)
        bindFn('binda','bindb')
        bindFn('binda111','bindb111')
        bindFn('binda222','bindb222')
        fn('fna','fnb')

    </script>
</body>
</html>